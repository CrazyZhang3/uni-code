(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CODE = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var ADELTA = [
        0, 11, 15, 19, 23, 27, 31, 16,
        18, 20, 22, 24, 26, 28, 20, 22,
        24, 24, 26, 28, 28, 22, 24, 24,
        26, 26, 28, 28, 24, 24, 26, 26,
        26, 28, 28, 24, 26, 26, 26, 28, 28
    ];
    var VPAT = [
        0xc94, 0x5bc, 0xa99, 0x4d3, 0xbf6, 0x762, 0x847, 0x60d,
        0x928, 0xb78, 0x45d, 0xa17, 0x532, 0x9a6, 0x683, 0x8c9,
        0x7ec, 0xec4, 0x1e1, 0xfab, 0x08e, 0xc1a, 0x33f, 0xd75,
        0x250, 0x9d5, 0x6f0, 0x8ba, 0x79f, 0xb0b, 0x42e, 0xa64,
        0x541, 0xc69
    ];
    var fmtword = [
        0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976,
        0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0,
        0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed,
        0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b
    ];
    var ECBLOCKS = [
        1, 0, 19, 7, 1, 0, 16, 10, 1, 0, 13, 13, 1, 0, 9, 17, 1, 0, 34, 10, 1, 0, 28, 16, 1, 0, 22, 22, 1, 0, 16, 28, 1, 0, 55, 15, 1, 0, 44, 26, 2, 0, 17, 18, 2, 0, 13, 22, 1, 0, 80,
        20, 2, 0, 32, 18, 2, 0, 24, 26, 4, 0, 9, 16, 1, 0, 108, 26, 2, 0, 43, 24, 2, 2, 15, 18, 2, 2, 11, 22, 2, 0, 68, 18, 4, 0, 27, 16, 4, 0, 19, 24, 4, 0, 15, 28, 2, 0, 78, 20, 4,
        0, 31, 18, 2, 4, 14, 18, 4, 1, 13, 26, 2, 0, 97, 24, 2, 2, 38, 22, 4, 2, 18, 22, 4, 2, 14, 26, 2, 0, 116, 30, 3, 2, 36, 22, 4, 4, 16, 20, 4, 4, 12, 24, 2, 2, 68, 18, 4, 1, 43,
        26, 6, 2, 19, 24, 6, 2, 15, 28, 4, 0, 81, 20, 1, 4, 50, 30, 4, 4, 22, 28, 3, 8, 12, 24, 2, 2, 92, 24, 6, 2, 36, 22, 4, 6, 20, 26, 7, 4, 14, 28, 4, 0, 107, 26, 8, 1, 37, 22, 8,
        4, 20, 24, 12, 4, 11, 22, 3, 1, 115, 30, 4, 5, 40, 24, 11, 5, 16, 20, 11, 5, 12, 24, 5, 1, 87, 22, 5, 5, 41, 24, 5, 7, 24, 30, 11, 7, 12, 24, 5, 1, 98, 24, 7, 3, 45, 28, 15, 2,
        19, 24, 3, 13, 15, 30, 1, 5, 107, 28, 10, 1, 46, 28, 1, 15, 22, 28, 2, 17, 14, 28, 5, 1, 120, 30, 9, 4, 43, 26, 17, 1, 22, 28, 2, 19, 14, 28, 3, 4, 113, 28, 3, 11, 44, 26, 17, 4,
        21, 26, 9, 16, 13, 26, 3, 5, 107, 28, 3, 13, 41, 26, 15, 5, 24, 30, 15, 10, 15, 28, 4, 4, 116, 28, 17, 0, 42, 26, 17, 6, 22, 28, 19, 6, 16, 30, 2, 7, 111, 28, 17, 0, 46, 28, 7, 16,
        24, 30, 34, 0, 13, 24, 4, 5, 121, 30, 4, 14, 47, 28, 11, 14, 24, 30, 16, 14, 15, 30, 6, 4, 117, 30, 6, 14, 45, 28, 11, 16, 24, 30, 30, 2, 16, 30, 8, 4, 106, 26, 8, 13, 47, 28, 7, 22,
        24, 30, 22, 13, 15, 30, 10, 2, 114, 28, 19, 4, 46, 28, 28, 6, 22, 28, 33, 4, 16, 30, 8, 4, 122, 30, 22, 3, 45, 28, 8, 26, 23, 30, 12, 28, 15, 30, 3, 10, 117, 30, 3, 23, 45, 28, 4, 31,
        24, 30, 11, 31, 15, 30, 7, 7, 116, 30, 21, 7, 45, 28, 1, 37, 23, 30, 19, 26, 15, 30, 5, 10, 115, 30, 19, 10, 47, 28, 15, 25, 24, 30, 23, 25, 15, 30, 13, 3, 115, 30, 2, 29, 46, 28, 42,
        1, 24, 30, 23, 28, 15, 30, 17, 0, 115, 30, 10, 23, 46, 28, 10, 35, 24, 30, 19, 35, 15, 30, 17, 1, 115, 30, 14, 21, 46, 28, 29, 19, 24, 30, 11, 46, 15, 30, 13, 6, 115, 30, 14, 23, 46,
        28, 44, 7, 24, 30, 59, 1, 16, 30, 12, 7, 121, 30, 12, 26, 47, 28, 39, 14, 24, 30, 22, 41, 15, 30, 6, 14, 121, 30, 6, 34, 47, 28, 46, 10, 24, 30, 2, 64, 15, 30, 17, 4, 122, 30, 29, 14,
        46, 28, 49, 10, 24, 30, 24, 46, 15, 30, 4, 18, 122, 30, 13, 32, 46, 28, 48, 14, 24, 30, 42, 32, 15, 30, 20, 4, 117, 30, 40, 7, 47, 28, 43, 22, 24, 30, 10, 67, 15, 30, 19, 6, 118, 30,
        18, 31, 47, 28, 34, 34, 24, 30, 20, 61, 15, 30
    ];
    var GLOG = [
        0xff, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,
        0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,
        0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,
        0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9, 0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,
        0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd, 0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,
        0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,
        0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,
        0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,
        0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,
        0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,
        0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,
        0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,
        0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,
        0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa, 0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,
        0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,
        0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf
    ];
    var GEXP = [
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
        0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
        0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
        0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
        0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
        0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
        0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
        0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
        0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
        0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
        0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
        0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
        0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
        0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
        0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
        0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e, 0x00
    ];
    var PATTERNS = [
        [2, 1, 2, 2, 2, 2, 0, 0],
        [2, 2, 2, 1, 2, 2, 0, 0],
        [2, 2, 2, 2, 2, 1, 0, 0],
        [1, 2, 1, 2, 2, 3, 0, 0],
        [1, 2, 1, 3, 2, 2, 0, 0],
        [1, 3, 1, 2, 2, 2, 0, 0],
        [1, 2, 2, 2, 1, 3, 0, 0],
        [1, 2, 2, 3, 1, 2, 0, 0],
        [1, 3, 2, 2, 1, 2, 0, 0],
        [2, 2, 1, 2, 1, 3, 0, 0],
        [2, 2, 1, 3, 1, 2, 0, 0],
        [2, 3, 1, 2, 1, 2, 0, 0],
        [1, 1, 2, 2, 3, 2, 0, 0],
        [1, 2, 2, 1, 3, 2, 0, 0],
        [1, 2, 2, 2, 3, 1, 0, 0],
        [1, 1, 3, 2, 2, 2, 0, 0],
        [1, 2, 3, 1, 2, 2, 0, 0],
        [1, 2, 3, 2, 2, 1, 0, 0],
        [2, 2, 3, 2, 1, 1, 0, 0],
        [2, 2, 1, 1, 3, 2, 0, 0],
        [2, 2, 1, 2, 3, 1, 0, 0],
        [2, 1, 3, 2, 1, 2, 0, 0],
        [2, 2, 3, 1, 1, 2, 0, 0],
        [3, 1, 2, 1, 3, 1, 0, 0],
        [3, 1, 1, 2, 2, 2, 0, 0],
        [3, 2, 1, 1, 2, 2, 0, 0],
        [3, 2, 1, 2, 2, 1, 0, 0],
        [3, 1, 2, 2, 1, 2, 0, 0],
        [3, 2, 2, 1, 1, 2, 0, 0],
        [3, 2, 2, 2, 1, 1, 0, 0],
        [2, 1, 2, 1, 2, 3, 0, 0],
        [2, 1, 2, 3, 2, 1, 0, 0],
        [2, 3, 2, 1, 2, 1, 0, 0],
        [1, 1, 1, 3, 2, 3, 0, 0],
        [1, 3, 1, 1, 2, 3, 0, 0],
        [1, 3, 1, 3, 2, 1, 0, 0],
        [1, 1, 2, 3, 1, 3, 0, 0],
        [1, 3, 2, 1, 1, 3, 0, 0],
        [1, 3, 2, 3, 1, 1, 0, 0],
        [2, 1, 1, 3, 1, 3, 0, 0],
        [2, 3, 1, 1, 1, 3, 0, 0],
        [2, 3, 1, 3, 1, 1, 0, 0],
        [1, 1, 2, 1, 3, 3, 0, 0],
        [1, 1, 2, 3, 3, 1, 0, 0],
        [1, 3, 2, 1, 3, 1, 0, 0],
        [1, 1, 3, 1, 2, 3, 0, 0],
        [1, 1, 3, 3, 2, 1, 0, 0],
        [1, 3, 3, 1, 2, 1, 0, 0],
        [3, 1, 3, 1, 2, 1, 0, 0],
        [2, 1, 1, 3, 3, 1, 0, 0],
        [2, 3, 1, 1, 3, 1, 0, 0],
        [2, 1, 3, 1, 1, 3, 0, 0],
        [2, 1, 3, 3, 1, 1, 0, 0],
        [2, 1, 3, 1, 3, 1, 0, 0],
        [3, 1, 1, 1, 2, 3, 0, 0],
        [3, 1, 1, 3, 2, 1, 0, 0],
        [3, 3, 1, 1, 2, 1, 0, 0],
        [3, 1, 2, 1, 1, 3, 0, 0],
        [3, 1, 2, 3, 1, 1, 0, 0],
        [3, 3, 2, 1, 1, 1, 0, 0],
        [3, 1, 4, 1, 1, 1, 0, 0],
        [2, 2, 1, 4, 1, 1, 0, 0],
        [4, 3, 1, 1, 1, 1, 0, 0],
        [1, 1, 1, 2, 2, 4, 0, 0],
        [1, 1, 1, 4, 2, 2, 0, 0],
        [1, 2, 1, 1, 2, 4, 0, 0],
        [1, 2, 1, 4, 2, 1, 0, 0],
        [1, 4, 1, 1, 2, 2, 0, 0],
        [1, 4, 1, 2, 2, 1, 0, 0],
        [1, 1, 2, 2, 1, 4, 0, 0],
        [1, 1, 2, 4, 1, 2, 0, 0],
        [1, 2, 2, 1, 1, 4, 0, 0],
        [1, 2, 2, 4, 1, 1, 0, 0],
        [1, 4, 2, 1, 1, 2, 0, 0],
        [1, 4, 2, 2, 1, 1, 0, 0],
        [2, 4, 1, 2, 1, 1, 0, 0],
        [2, 2, 1, 1, 1, 4, 0, 0],
        [4, 1, 3, 1, 1, 1, 0, 0],
        [2, 4, 1, 1, 1, 2, 0, 0],
        [1, 3, 4, 1, 1, 1, 0, 0],
        [1, 1, 1, 2, 4, 2, 0, 0],
        [1, 2, 1, 1, 4, 2, 0, 0],
        [1, 2, 1, 2, 4, 1, 0, 0],
        [1, 1, 4, 2, 1, 2, 0, 0],
        [1, 2, 4, 1, 1, 2, 0, 0],
        [1, 2, 4, 2, 1, 1, 0, 0],
        [4, 1, 1, 2, 1, 2, 0, 0],
        [4, 2, 1, 1, 1, 2, 0, 0],
        [4, 2, 1, 2, 1, 1, 0, 0],
        [2, 1, 2, 1, 4, 1, 0, 0],
        [2, 1, 4, 1, 2, 1, 0, 0],
        [4, 1, 2, 1, 2, 1, 0, 0],
        [1, 1, 1, 1, 4, 3, 0, 0],
        [1, 1, 1, 3, 4, 1, 0, 0],
        [1, 3, 1, 1, 4, 1, 0, 0],
        [1, 1, 4, 1, 1, 3, 0, 0],
        [1, 1, 4, 3, 1, 1, 0, 0],
        [4, 1, 1, 1, 1, 3, 0, 0],
        [4, 1, 1, 3, 1, 1, 0, 0],
        [1, 1, 3, 1, 4, 1, 0, 0],
        [1, 1, 4, 1, 3, 1, 0, 0],
        [3, 1, 1, 1, 4, 1, 0, 0],
        [4, 1, 1, 1, 3, 1, 0, 0],
        [2, 1, 1, 4, 1, 2, 0, 0],
        [2, 1, 1, 2, 1, 4, 0, 0],
        [2, 1, 1, 2, 3, 2, 0, 0],
        [2, 3, 3, 1, 1, 1, 2, 0]
    ];

    var UNIT_CONVERSION = function (num) {
        return uni.upx2px(Number(num));
    };
    var UtF16TO8 = function (code) {
        var out = '';
        var c = 0;
        for (var i = 0; i < code.length; i++) {
            c = code.charCodeAt(i);
            if ((c >= 0x0001) && (c <= 0x007F)) {
                out += code.charAt(i);
            }
            else if (c > 0x07FF) {
                out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));
                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));
            }
            else {
                out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));
                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));
            }
        }
        return out;
    };
    var GetBytes = function (str) {
        var bytes = [];
        for (var i = 0; i < str.length; i++) {
            bytes.push(str.charCodeAt(i));
        }
        return bytes;
    };
    var CodeSetAllowedFor = function (chr) {
        if (chr >= 48 && chr <= 57) {
            return CODESET.ANY;
        }
        else if (chr >= 32 && chr <= 95) {
            return CODESET.AB;
        }
        else {
            return chr < 32 ? CODESET.A : CODESET.B;
        }
    };
    var getBestStartSet = function (csa1, csa2) {
        var vote = 0;
        vote += csa1 == CODESET.A ? 1 : 0;
        vote += csa1 == CODESET.B ? -1 : 0;
        vote += csa2 == CODESET.A ? 1 : 0;
        vote += csa2 == CODESET.B ? -1 : 0;
        return vote > 0 ? CODESET.A : CODESET.B;
    };
    var codeValue = function (chr1, chr2) {
        if (typeof chr2 == "undefined") {
            return chr1 >= 32 ? chr1 - 32 : chr1 + 64;
        }
        else {
            return parseInt(String.fromCharCode(chr1) + String.fromCharCode(chr2));
        }
    };
    var charCompatible = function (chr, codeset) {
        var csa = codeSetAllowedFor(chr);
        if (csa == CODESET.ANY)
            return true;
        if (csa == CODESET.AB)
            return true;
        if (csa == CODESET.A && codeset == CODESET.A)
            return true;
        if (csa == CODESET.B && codeset == CODESET.B)
            return true;
        return false;
    };
    var codeSetAllowedFor = function (chr) {
        if (chr >= 48 && chr <= 57) {
            return CODESET.ANY;
        }
        else if (chr >= 32 && chr <= 95) {
            return CODESET.AB;
        }
        else {
            return chr < 32 ? CODESET.A : CODESET.B;
        }
    };
    var SaveCodeImg = function (k) {
        var width = UNIT_CONVERSION(Number(k.width));
        var height = UNIT_CONVERSION(Number(k.height));
        return new Promise(function (resolve) {
            if (Object.prototype.toString.call(k.id) == '[object String]') {
                uni.canvasToTempFilePath({
                    canvasId: k.id,
                    width: width,
                    height: height,
                    destWidth: width,
                    destHeight: height,
                    fileType: k.type || 'png',
                    quality: k.quality || 1,
                    complete: function (res) {
                        resolve(res);
                    }
                }, k.ctx);
            }
            else if (Object.prototype.toString.call(k.id) == '[object Object]') {
                var ctx = k.id;
                ctx.toTempFilePath(0, 0, width, height, width, height, k.type || 'png', 1, function (res) {
                    resolve(res);
                });
            }
        });
    };
    var StringToCode128 = function (code) {
        var barc = {
            currcs: CODESET.C
        };
        var bytes = GetBytes(code);
        var index = bytes[0] == CHAR_TILDE ? 1 : 0;
        var perhapsCodeC = function (bytes, codeset) {
            for (var i = 0; i < bytes.length; i++) {
                var b = bytes[i];
                if ((b < 48 || b > 57) && b != CHAR_TILDE)
                    return codeset;
            }
            return CODESET.C;
        };
        var codesForChar = function (chr1, chr2, currcs) {
            var result = [];
            var shifter = -1;
            if (charCompatible(chr1, currcs)) {
                if (currcs == CODESET.C) {
                    if (chr2 == -1) {
                        shifter = SET_CODEB;
                        currcs = CODESET.B;
                    }
                    else if ((chr2 != -1) && !charCompatible(chr2, currcs)) {
                        if (charCompatible(chr2, CODESET.A)) {
                            shifter = SET_CODEA;
                            currcs = CODESET.A;
                        }
                        else {
                            shifter = SET_CODEB;
                            currcs = CODESET.B;
                        }
                    }
                }
            }
            else {
                if ((chr2 != -1) && !charCompatible(chr2, currcs)) {
                    switch (currcs) {
                        case CODESET.A:
                            shifter = SET_CODEB;
                            currcs = CODESET.B;
                            break;
                        case CODESET.B:
                            shifter = SET_CODEA;
                            currcs = CODESET.A;
                            break;
                    }
                }
                else {
                    shifter = SET_SHIFT;
                }
            }
            if (shifter != -1) {
                result.push(shifter);
                result.push(codeValue(chr1));
            }
            else {
                if (currcs == CODESET.C) {
                    result.push(codeValue(chr1, chr2));
                }
                else {
                    result.push(codeValue(chr1));
                }
            }
            barc.currcs = currcs;
            return result;
        };
        var csa1 = bytes.length > 0 ? CodeSetAllowedFor(bytes[index++]) : CODESET.AB;
        var csa2 = bytes.length > 0 ? CodeSetAllowedFor(bytes[index++]) : CODESET.AB;
        barc.currcs = getBestStartSet(csa1, csa2);
        barc.currcs = perhapsCodeC(bytes, barc.currcs);
        var codes = [];
        switch (barc.currcs) {
            case CODESET.A:
                codes.push(SET_STARTA);
                break;
            case CODESET.B:
                codes.push(SET_STARTB);
                break;
            default:
                codes.push(SET_STARTC);
                break;
        }
        for (var i = 0; i < bytes.length; i++) {
            var b1 = bytes[i];
            if (b1 in REPLACE_CODES) {
                codes.push(REPLACE_CODES[b1]);
                i++;
                b1 = bytes[i];
            }
            var b2 = bytes.length > (i + 1) ? bytes[i + 1] : -1;
            codes = codes.concat(codesForChar(b1, b2, barc.currcs));
            if (barc.currcs == CODESET.C)
                i++;
        }
        var checksum = codes[0];
        for (var weight = 1; weight < codes.length; weight++) {
            checksum += (weight * codes[weight]);
        }
        codes.push(checksum % 103);
        codes.push(SET_STOP);
        return codes;
    };
    var QRCodeInit = (function () {
        function QRCodeInit(level) {
            if (level === void 0) { level = 4; }
            this.strinbuf = [];
            this.eccbuf = [];
            this.qrframe = [];
            this.framask = [];
            this.rlens = [];
            this.genpoly = [];
            this.ecclevel = 4;
            this.N1 = 3;
            this.N2 = 3;
            this.N3 = 40;
            this.N4 = 10;
            this.neccblk2 = 0;
            this.width = 0;
            this.neccblk1 = 0;
            this.datablkw = 0;
            this.eccblkwid = 0;
            this.ecclevel = level;
        }
        QRCodeInit.prototype.setmask = function (x, y) {
            var bt = null;
            if (x > y) {
                bt = x;
                x = y;
                y = bt;
            }
            bt = y;
            bt *= y;
            bt += y;
            bt >>= 1;
            bt += x;
            this.framask[bt] = 1;
        };
        QRCodeInit.prototype.getWidth = function () {
            return this.width;
        };
        QRCodeInit.prototype.putalign = function (x, y) {
            this.qrframe[x + this.width * y] = 1;
            for (var j = -2; j < 2; j++) {
                this.qrframe[(x + j) + this.width * (y - 2)] = 1;
                this.qrframe[(x - 2) + this.width * (y + j + 1)] = 1;
                this.qrframe[(x + 2) + this.width * (y + j)] = 1;
                this.qrframe[(x + j + 1) + this.width * (y + 2)] = 1;
            }
            for (var j = 0; j < 2; j++) {
                this.setmask(x - 1, y + j);
                this.setmask(x + 1, y - j);
                this.setmask(x - j, y - 1);
                this.setmask(x + j, y + 1);
            }
        };
        QRCodeInit.prototype.modnn = function (x) {
            while (x >= 255) {
                x -= 255;
                x = (x >> 8) + (x & 255);
            }
            return x;
        };
        QRCodeInit.prototype.appendrs = function (data, dlen, ecbuf, eclen) {
            var fb;
            for (var i = 0; i < eclen; i++) {
                this.strinbuf[ecbuf + i] = 0;
            }
            for (var i = 0; i < dlen; i++) {
                fb = GLOG[this.strinbuf[data + i] ^ this.strinbuf[ecbuf]];
                if (fb != 255) {
                    for (var j = 1; j < eclen; j++) {
                        this.strinbuf[ecbuf + j - 1] = this.strinbuf[ecbuf + j] ^ GEXP[this.modnn(fb + this.genpoly[eclen - j])];
                    }
                }
                else {
                    for (var j = ecbuf; j < ecbuf + eclen; j++) {
                        this.strinbuf[j] = this.strinbuf[j + 1];
                    }
                }
                this.strinbuf[ecbuf + eclen - 1] = fb == 255 ? 0 : GEXP[this.modnn(fb + this.genpoly[0])];
            }
        };
        QRCodeInit.prototype.ismasked = function (x, y) {
            var bt;
            if (x > y) {
                bt = x;
                x = y;
                y = bt;
            }
            bt = y;
            bt += y * y;
            bt >>= 1;
            bt += x;
            return this.framask[bt];
        };
        QRCodeInit.prototype.badruns = function (length) {
            var runsbad = 0;
            for (var i = 0; i <= length; i++) {
                if (this.rlens[i] >= 5) {
                    runsbad += this.N1 + this.rlens[i] - 5;
                }
            }
            for (var i = 3; i < length - 1; i += 2) {
                if (this.rlens[i - 2] == this.rlens[i + 2]
                    && this.rlens[i + 2] == this.rlens[i - 1]
                    && this.rlens[i - 1] == this.rlens[i + 1]
                    && this.rlens[i - 1] * 3 == this.rlens[i]
                    && (this.rlens[i - 3] == 0
                        || i + 3 > length
                        || this.rlens[i - 3] * 3 >= this.rlens[i] * 4 || this.rlens[i + 3] * 3 >= this.rlens[i] * 4)) {
                    runsbad += this.N3;
                }
            }
            return runsbad;
        };
        QRCodeInit.prototype.toNum = function (num) {
            return num === 0 ? 1 : 0;
        };
        QRCodeInit.prototype.applymask = function (m) {
            switch (m) {
                case 0:
                    for (var y = 0; y < this.width; y++) {
                        for (var x = 0; x < this.width; x++) {
                            if (!((x + y) & 1) && !this.ismasked(x, y)) {
                                this.qrframe[x + y * this.width] ^= 1;
                            }
                        }
                    }
                    break;
                case 1:
                    for (var y = 0; y < this.width; y++) {
                        for (var x = 0; x < this.width; x++) {
                            if (!(y & 1) && !this.ismasked(x, y)) {
                                this.qrframe[x + y * this.width] ^= 1;
                            }
                        }
                    }
                    break;
                case 2:
                    for (var y = 0; y < this.width; y++)
                        for (var r3x = 0, x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3) {
                                r3x = 0;
                            }
                            if (!r3x && !this.ismasked(x, y)) {
                                this.qrframe[x + y * this.width] ^= 1;
                            }
                        }
                    break;
                case 3:
                    for (var r3y = 0, y = 0; y < this.width; y++, r3y++) {
                        if (r3y == 3) {
                            r3y = 0;
                        }
                        for (var r3x = r3y, x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3) {
                                r3x = 0;
                            }
                            if (!r3x && !this.ismasked(x, y)) {
                                this.qrframe[x + y * this.width] ^= 1;
                            }
                        }
                    }
                    break;
                case 4:
                    for (var y = 0; y < this.width; y++)
                        for (var r3x = 0, r3y = ((y >> 1) & 1), x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3) {
                                r3x = 0;
                                r3y = r3y > 0 ? 0 : 1;
                            }
                            if (!r3y && !this.ismasked(x, y))
                                this.qrframe[x + y * this.width] ^= 1;
                        }
                    break;
                case 5:
                    for (var r3y = 0, y = 0; y < this.width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (var r3x = 0, x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!((x & y & 1) + this.toNum((this.toNum(r3x) | this.toNum(r3y)))) && !this.ismasked(x, y))
                                this.qrframe[x + y * this.width] ^= 1;
                        }
                    }
                    break;
                case 6:
                    for (var r3y = 0, y = 0; y < this.width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (var r3x = 0, x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!(((x & y & 1) + (r3x && (r3x == r3y ? 1 : 0))) & 1) && !this.ismasked(x, y))
                                this.qrframe[x + y * this.width] ^= 1;
                        }
                    }
                    break;
                case 7:
                    for (var r3y = 0, y = 0; y < this.width; y++, r3y++) {
                        if (r3y == 3)
                            r3y = 0;
                        for (var r3x = 0, x = 0; x < this.width; x++, r3x++) {
                            if (r3x == 3)
                                r3x = 0;
                            if (!(((r3x && (r3x == r3y ? 1 : 0)) + ((x + y) & 1)) & 1) && !this.ismasked(x, y))
                                this.qrframe[x + y * this.width] ^= 1;
                        }
                    }
                    break;
            }
            return;
        };
        QRCodeInit.prototype.Genframe = function (code) {
            var TT = code.length;
            var CODES = code.slice(0);
            var XX = 0;
            var KK = 0;
            var YY = 0;
            var VV = 0;
            var version = 0;
            var IF = 0;
            var MM = 0;
            do {
                version++;
                KK = (this.ecclevel - 1) * 4 + (version - 1) * 16;
                this.neccblk1 = ECBLOCKS[KK++];
                this.neccblk2 = ECBLOCKS[KK++];
                this.datablkw = ECBLOCKS[KK++];
                this.eccblkwid = ECBLOCKS[KK];
                KK = this.datablkw * (this.neccblk1 + this.neccblk2) + this.neccblk2 - 3 + (version <= 9 ? 1 : 0);
                if (TT <= KK)
                    break;
            } while (version < 40);
            this.width = 17 + 4 * version;
            VV = this.datablkw + (this.datablkw + this.eccblkwid) * (this.neccblk1 + this.neccblk2) + this.neccblk2;
            for (var t = 0; t < VV; t++) {
                this.eccbuf[t] = 0;
            }
            for (var t = 0; t < this.width * this.width; t++) {
                this.qrframe[t] = 0;
            }
            for (var t = 0; t < (this.width * (this.width + 1) + 1) / 2; t++) {
                this.framask[t] = 0;
            }
            for (var t = 0; t < 3; t++) {
                KK = 0;
                YY = 0;
                if (t == 1) {
                    KK = (this.width - 7);
                }
                if (t == 2) {
                    YY = (this.width - 7);
                }
                this.qrframe[(YY + 3) + this.width * (KK + 3)] = 1;
                for (var x = 0; x < 6; x++) {
                    this.qrframe[(YY + x) + this.width * KK] = 1;
                    this.qrframe[YY + this.width * (KK + x + 1)] = 1;
                    this.qrframe[(YY + 6) + this.width * (KK + x)] = 1;
                    this.qrframe[(YY + x + 1) + this.width * (KK + 6)] = 1;
                }
                for (var x = 1; x < 5; x++) {
                    this.setmask(YY + x, KK + 1);
                    this.setmask(YY + 1, KK + x + 1);
                    this.setmask(YY + 5, KK + x);
                    this.setmask(YY + x + 1, KK + 5);
                }
                for (var x = 2; x < 4; x++) {
                    this.qrframe[(YY + x) + this.width * (KK + 2)] = 1;
                    this.qrframe[(YY + 2) + this.width * (KK + x + 1)] = 1;
                    this.qrframe[(YY + 4) + this.width * (KK + x)] = 1;
                    this.qrframe[(YY + x + 1) + this.width * (KK + 4)] = 1;
                }
            }
            if (version > 1) {
                TT = ADELTA[version];
                YY = this.width - 7;
                for (;;) {
                    XX = this.width - 7;
                    while (XX > TT - 3) {
                        this.putalign(XX, YY);
                        if (XX < TT)
                            break;
                        XX -= TT;
                    }
                    if (YY <= TT + 9)
                        break;
                    YY -= TT;
                    this.putalign(6, YY);
                    this.putalign(YY, 6);
                }
            }
            this.qrframe[8 + this.width * (this.width - 8)] = 1;
            for (var y = 0; y < 7; y++) {
                this.setmask(7, y);
                this.setmask(this.width - 8, y);
                this.setmask(7, y + this.width - 7);
            }
            for (var x = 0; x < 8; x++) {
                this.setmask(x, 7);
                this.setmask(x + this.width - 8, 7);
                this.setmask(x, this.width - 8);
            }
            for (var x = 0; x < 9; x++)
                this.setmask(x, 8);
            for (var x = 0; x < 8; x++) {
                this.setmask(x + this.width - 8, 8);
                this.setmask(8, x);
            }
            for (var y = 0; y < 7; y++) {
                this.setmask(8, y + this.width - 7);
            }
            for (var x = 0; x < this.width - 14; x++) {
                if (x & 1) {
                    this.setmask(8 + x, 6);
                    this.setmask(6, 8 + x);
                }
                else {
                    this.qrframe[(8 + x) + this.width * 6] = 1;
                    this.qrframe[6 + this.width * (8 + x)] = 1;
                }
            }
            if (version > 6) {
                TT = VPAT[version - 7];
                KK = 17;
                for (var x = 0; x < 6; x++) {
                    for (var y = 0; y < 3; y++, KK--) {
                        if (1 & (KK > 11 ? version >> (KK - 12) : TT >> KK)) {
                            this.qrframe[(5 - x) + this.width * (2 - y + this.width - 11)] = 1;
                            this.qrframe[(2 - y + this.width - 11) + this.width * (5 - x)] = 1;
                        }
                        else {
                            this.setmask(5 - x, 2 - y + this.width - 11);
                            this.setmask(2 - y + this.width - 11, 5 - x);
                        }
                    }
                }
            }
            for (var y = 0; y < this.width; y++) {
                for (var x = 0; x <= y; x++) {
                    if (this.qrframe[x + this.width * y]) {
                        this.setmask(x, y);
                    }
                }
            }
            VV = CODES.length;
            for (var i = 0; i < VV; i++) {
                this.eccbuf[i] = CODES.charCodeAt(i);
            }
            this.strinbuf = this.eccbuf.slice(0);
            XX = this.datablkw * (this.neccblk1 + this.neccblk2) + this.neccblk2;
            if (VV >= XX - 2) {
                VV = XX - 2;
                if (version > 9) {
                    VV--;
                }
            }
            IF = VV;
            if (version > 9) {
                this.strinbuf[IF + 2] = 0;
                this.strinbuf[IF + 3] = 0;
                while (IF--) {
                    TT = this.strinbuf[IF];
                    this.strinbuf[IF + 3] |= 255 & (TT << 4);
                    this.strinbuf[IF + 2] = TT >> 4;
                }
                this.strinbuf[2] |= 255 & (VV << 4);
                this.strinbuf[1] = VV >> 4;
                this.strinbuf[0] = 0x40 | (VV >> 12);
            }
            else {
                this.strinbuf[IF + 1] = 0;
                this.strinbuf[IF + 2] = 0;
                while (IF--) {
                    TT = this.strinbuf[IF];
                    this.strinbuf[IF + 2] |= 255 & (TT << 4);
                    this.strinbuf[IF + 1] = TT >> 4;
                }
                this.strinbuf[1] |= 255 & (VV << 4);
                this.strinbuf[0] = 0x40 | (VV >> 4);
            }
            IF = VV + 3 - (version < 10 ? 1 : 0);
            while (IF < XX) {
                this.strinbuf[IF++] = 0xec;
                this.strinbuf[IF++] = 0x11;
            }
            this.genpoly[0] = 1;
            for (var i = 0; i < this.eccblkwid; i++) {
                this.genpoly[i + 1] = 1;
                for (var j = i; j > 0; j--) {
                    this.genpoly[j] = this.genpoly[j] ? this.genpoly[j - 1] ^ GEXP[this.modnn(GLOG[this.genpoly[j]] + i)] : this.genpoly[j - 1];
                }
                this.genpoly[0] = GEXP[this.modnn(GLOG[this.genpoly[0]] + i)];
            }
            for (var i = 0; i <= this.eccblkwid; i++) {
                this.genpoly[i] = GLOG[this.genpoly[i]];
            }
            KK = XX;
            YY = 0;
            for (var i = 0; i < this.neccblk1; i++) {
                this.appendrs(YY, this.datablkw, KK, this.eccblkwid);
                YY += this.datablkw;
                KK += this.eccblkwid;
            }
            for (var i = 0; i < this.neccblk2; i++) {
                this.appendrs(YY, this.datablkw + 1, KK, this.eccblkwid);
                YY += this.datablkw + 1;
                KK += this.eccblkwid;
            }
            YY = 0;
            for (var i = 0; i < this.datablkw; i++) {
                for (var j = 0; j < this.neccblk1; j++) {
                    this.eccbuf[YY++] = this.strinbuf[i + j * this.datablkw];
                }
                for (var j = 0; j < this.neccblk2; j++) {
                    this.eccbuf[YY++] = this.strinbuf[(this.neccblk1 * this.datablkw) + i + (j * (this.datablkw + 1))];
                }
            }
            for (var j = 0; j < this.neccblk2; j++) {
                this.eccbuf[YY++] = this.strinbuf[(this.neccblk1 * this.datablkw) + IF + (j * (this.datablkw + 1))];
            }
            for (var i = 0; i < this.eccblkwid; i++) {
                for (var j = 0; j < this.neccblk1 + this.neccblk2; j++) {
                    this.eccbuf[YY++] = this.strinbuf[XX + i + j * this.eccblkwid];
                }
            }
            this.strinbuf = this.eccbuf;
            XX = YY = this.width - 1;
            KK = VV = 1;
            MM = (this.datablkw + this.eccblkwid) * (this.neccblk1 + this.neccblk2) + this.neccblk2;
            for (var i = 0; i < MM; i++) {
                TT = this.strinbuf[i];
                for (var j = 0; j < 8; j++, TT <<= 1) {
                    if (0x80 & TT) {
                        this.qrframe[XX + this.width * YY] = 1;
                    }
                    do {
                        if (VV)
                            XX--;
                        else {
                            XX++;
                            if (KK) {
                                if (YY != 0)
                                    YY--;
                                else {
                                    XX -= 2;
                                    KK = (KK === 0 ? 1 : 0);
                                    if (XX == 6) {
                                        XX--;
                                        YY = 9;
                                    }
                                }
                            }
                            else {
                                if (YY != this.width - 1)
                                    YY++;
                                else {
                                    XX -= 2;
                                    KK = (KK === 0 ? 1 : 0);
                                    if (XX == 6) {
                                        XX--;
                                        YY -= 8;
                                    }
                                }
                            }
                        }
                        VV = (VV > 0 ? 0 : 1);
                    } while (this.ismasked(XX, YY));
                }
            }
            this.strinbuf = this.qrframe.slice(0);
            TT = 0;
            YY = 30000;
            for (var k = 0; k < 8; k++) {
                this.applymask(k);
                XX = this.badcheck();
                if (XX < YY) {
                    YY = XX;
                    TT = k;
                }
                if (TT == 7)
                    break;
                this.qrframe = this.strinbuf.slice(0);
            }
            if (TT != KK) {
                this.applymask(TT);
            }
            YY = fmtword[TT + ((this.ecclevel - 1) << 3)];
            for (var k = 0; k < 8; k++, YY >>= 1) {
                if (YY & 1) {
                    this.qrframe[(this.width - 1 - k) + this.width * 8] = 1;
                    if (k < 6) {
                        this.qrframe[8 + this.width * k] = 1;
                    }
                    else {
                        this.qrframe[8 + this.width * (k + 1)] = 1;
                    }
                }
            }
            for (var k = 0; k < 7; k++, YY >>= 1) {
                if (YY & 1) {
                    this.qrframe[8 + this.width * (this.width - 7 + k)] = 1;
                    if (k) {
                        this.qrframe[(6 - k) + this.width * 8] = 1;
                    }
                    else {
                        this.qrframe[7 + this.width * 8] = 1;
                    }
                }
            }
            return this.qrframe;
        };
        QRCodeInit.prototype.badcheck = function () {
            var thisbad = 0;
            var bw = 0;
            var h = 0;
            var b = 0;
            var b1 = 0;
            var w = 0;
            var f = 0;
            for (var y = 0; y < this.width - 1; y++) {
                for (var x = 0; x < this.width - 1; x++)
                    if ((this.qrframe[x + this.width * y] && this.qrframe[(x + 1) + this.width * y]
                        && this.qrframe[x + this.width * (y + 1)] && this.qrframe[(x + 1) + this.width * (y + 1)])
                        || !(this.qrframe[x + this.width * y] || this.qrframe[(x + 1) + this.width * y]
                            || this.qrframe[x + this.width * (y + 1)] || this.qrframe[(x + 1) + this.width * (y + 1)])) {
                        thisbad += this.N2;
                    }
            }
            for (var y = 0; y < this.width; y++) {
                this.rlens[0] = 0;
                for (h = b = w = 0; w < this.width; w++) {
                    if ((b1 = this.qrframe[w + this.width * y]) == b) {
                        this.rlens[h]++;
                    }
                    else {
                        this.rlens[++h] = 1;
                    }
                    b = b1;
                    bw += b ? 1 : -1;
                }
                thisbad += this.badruns(h);
            }
            if (bw < 0) {
                bw = -bw;
            }
            var big = bw;
            var count = 0;
            big += big << 2;
            big <<= 1;
            while (big > this.width * this.width)
                big -= this.width * this.width, count++;
            thisbad += count * this.N4;
            for (var x = 0; x < this.width; x++) {
                this.rlens[0] = 0;
                for (h = b = f = 0; f < this.width; f++) {
                    if ((b1 = this.qrframe[x + this.width * f]) == b) {
                        this.rlens[h]++;
                    }
                    else {
                        this.rlens[++h] = 1;
                    }
                    b = b1;
                }
                thisbad += this.badruns(h);
            }
            return thisbad;
        };
        return QRCodeInit;
    }());
    var CHAR_TILDE = 126;
    var CODE_FNC1 = 102;
    var SET_STARTA = 103;
    var SET_STARTB = 104;
    var SET_STARTC = 105;
    var SET_SHIFT = 98;
    var SET_CODEA = 101;
    var SET_CODEB = 100;
    var SET_STOP = 106;
    var REPLACE_CODES = {
        CHAR_TILDE: CODE_FNC1
    };
    var CODESET = {
        ANY: 1,
        AB: 2,
        A: 3,
        B: 4,
        C: 5
    };

    var OperationCode = function (opt, callback) {
        if (!opt.code) {
            console.warn("没有找到条形码code");
            return;
        }
        if (!opt.id) {
            console.warn("没有找到条形码canvas id或者实列!");
            return;
        }
        var CTX;
        if (Object.prototype.toString.call(opt.id) == '[object String]') {
            CTX = uni.createCanvasContext(opt.id, opt.ctx || null);
            BarCodeCanvas(opt, CTX, callback);
        }
        else if (Object.prototype.toString.call(opt.id) == '[object Object]') {
            CTX = opt.id;
            BarCodeCanvas(opt, CTX, callback);
        }
    };
    var BarCodeCanvas = function (opt, ctx, callback) {
        var _this = this;
        var width = UNIT_CONVERSION(opt.width);
        var height = UNIT_CONVERSION(opt.height);
        var CodeNum = StringToCode128(opt.code);
        var gc = new GraphicContent(ctx, width, height, opt.color || "#000000", opt.bgColor || "#ffffff");
        var barWeight = gc.area.width / ((CodeNum.length - 3) * 11 + 35);
        var x = gc.area.left;
        var y = gc.area.top;
        for (var i = 0; i < CodeNum.length; i++) {
            var c = CodeNum[i];
            for (var bar = 0; bar < 8; bar += 2) {
                var barW = PATTERNS[c][bar] * barWeight;
                var barH = height - y;
                var spcW = PATTERNS[c][bar + 1] * barWeight;
                if (barW > 0) {
                    gc.fillFgRect(x, y, barW, barH);
                }
                x += barW + spcW;
            }
        }
        ctx.draw(false, function (res) { return __awaiter(_this, void 0, void 0, function () {
            var _b, _c, _d;
            var _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (!callback) return [3, 2];
                        _c = (_b = callback).call;
                        _d = [__assign({}, res)];
                        _e = {};
                        return [4, SaveCodeImg({
                                width: opt.width,
                                height: opt.height,
                                id: opt.id,
                                ctx: opt.ctx || null
                            })];
                    case 1:
                        _c.apply(_b, [__assign.apply(void 0, _d.concat([(_e.img = _f.sent(), _e.id = Object.prototype.toString.call(opt.id) == '[object String]' ? opt.id : "nvue", _e)]))]);
                        return [3, 3];
                    case 2:
                        _f.label = 3;
                    case 3:
                        return [2];
                }
            });
        }); });
    };
    var GraphicContent = (function () {
        function GraphicContent(ctx, width, height, color, backGroud) {
            this.borderSize = 0;
            this.paddingWidth = 0;
            this.ctx = ctx;
            this.width = width;
            this.height = height;
            this.quiet = Math.round(this.width / 40);
            this.color = color;
            this.backGroud = backGroud;
            this.area = {
                width: width - this.paddingWidth * 2 - this.quiet * 2,
                height: height - this.borderSize * 2,
                top: this.borderSize - 4,
                left: this.borderSize + this.quiet
            };
            this.fillBgRect(0, 0, width, height);
            this.fillBgRect(0, this.borderSize, width, height - this.borderSize * 2);
        }
        GraphicContent.prototype.fillFgRect = function (x, y, width, height) {
            this.FILLRECT(x, y, width, height, this.color);
        };
        GraphicContent.prototype.fillBgRect = function (x, y, width, height) {
            this.FILLRECT(x, y, width, height, this.backGroud);
        };
        GraphicContent.prototype.FILLRECT = function (x, y, width, height, color) {
            this.ctx.setFillStyle(color);
            this.ctx.fillRect(x, y, width, height);
        };
        return GraphicContent;
    }());

    var WidgetCode = function (opt, method) {
        if (!opt.code) {
            console.warn("没有找到二维码code");
            return;
        }
        if (!opt.id) {
            console.warn("没有找到二维码canvas id或者实列!");
            return;
        }
        var CTX;
        var BARCODE = new QRCodeInit(opt.level);
        var CODE = UtF16TO8(opt.code);
        var frame = BARCODE.Genframe(CODE);
        var width = BARCODE.getWidth();
        if (Object.prototype.toString.call(opt.id) == '[object String]') {
            CTX = uni.createCanvasContext(opt.id, opt.ctx || null);
            RepaintCanvas(opt, CTX, frame, width, method);
        }
        else if (Object.prototype.toString.call(opt.id) == '[object Object]') {
            CTX = opt.id;
            RepaintCanvas(opt, CTX, frame, width, method);
        }
    };
    var RepaintCanvas = function (opt, ctx, frame, width, method) {
        var _this = this;
        var SIZE = UNIT_CONVERSION(opt.size);
        var px = Math.round(SIZE / (width + 8));
        var roundedSize = px * (width + 8);
        var offset = Math.floor((SIZE - roundedSize) / 2);
        ctx.clearRect(0, 0, SIZE, SIZE);
        ctx.setFillStyle(opt.bgColor || '#FFFFFF');
        ctx.fillRect(0, 0, SIZE, SIZE);
        opt.color ? SetColorCode(ctx, SIZE, opt.color) : ctx.setFillStyle("#000000");
        opt.border ? SetBorderCode(ctx, SIZE, opt.border) : false;
        for (var i = 0; i < width; i++) {
            for (var j = 0; j < width; j++) {
                if (frame[j * width + i]) {
                    ctx.fillRect(px * (4 + i) + offset, px * (4 + j) + offset, px, px);
                }
            }
        }
        opt.img ? SetImageCode(ctx, SIZE, opt.iconSize, opt.img) : false;
        ctx.draw(false, function (res) { return __awaiter(_this, void 0, void 0, function () {
            var _b, _c, _d, _e;
            var _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (!method) return [3, 4];
                        _c = (_b = method).apply;
                        _d = [__assign({}, res)];
                        _f = {};
                        if (!(res.errMsg == "drawCanvas:ok")) return [3, 2];
                        return [4, SaveCodeImg({
                                width: opt.size,
                                height: opt.size,
                                id: opt.id,
                                ctx: opt.ctx || null
                            })];
                    case 1:
                        _e = _g.sent();
                        return [3, 3];
                    case 2:
                        _e = null;
                        _g.label = 3;
                    case 3:
                        _c.apply(_b, [__assign.apply(void 0, _d.concat([(_f.img = _e, _f.id = Object.prototype.toString.call(opt.id) == '[object String]' ? opt.id : "nvue", _f)]))]);
                        return [3, 5];
                    case 4:
                        _g.label = 5;
                    case 5:
                        return [2];
                }
            });
        }); });
    };
    var SetColorCode = function (ctx, size, colors) {
        var Gradient = ctx.createLinearGradient(0, 0, size, 0);
        if (colors.length === 1) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(1, colors[0]);
        }
        if (colors.length === 2) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(1, colors[1]);
        }
        if (colors.length === 3) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(0.5, colors[1]);
            Gradient.addColorStop(1, colors[2]);
        }
        ctx.setFillStyle(Gradient);
    };
    var SetImageCode = function (ctx, size, iconSize, img) {
        if (iconSize === void 0) { iconSize = 30; }
        var width = Number(((size - (iconSize)) / 2).toFixed(2));
        ctx.drawImage(img, width, width, iconSize, iconSize);
    };
    var SetBorderCode = function (ctx, size, border) {
        var colors = (border === null || border === void 0 ? void 0 : border.color) || ['#000000'];
        var lineWidth = (border === null || border === void 0 ? void 0 : border.lineWidth) || 4;
        var Gradient = ctx.createLinearGradient(0, 0, size, 0);
        if (colors.length === 1) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(1, colors[0]);
        }
        if (colors.length === 2) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(1, colors[1]);
        }
        if (colors.length === 3) {
            Gradient.addColorStop(0, colors[0]);
            Gradient.addColorStop(0.5, colors[1]);
            Gradient.addColorStop(1, colors[2]);
        }
        ctx.setStrokeStyle(Gradient);
        ctx.setLineWidth(lineWidth);
        ctx.strokeRect(0, 0, size, size);
    };

    var BarCode = OperationCode;
    var QRCode = WidgetCode;

    exports.BarCode = BarCode;
    exports.QRCode = QRCode;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
